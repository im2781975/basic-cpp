// C++ program to show that we can access a global variable
// using scope resolution operator :: when there is a local 
// variable with same name 
#include<iostream> 
using namespace std;
 
int x; // Global x
 
int main()
{
int x = 10; // Local x
cout << "Value of global x is " << ::x;
cout << "\nValue of local x is " << x; 
return 0;
}
// Use of scope resolution operator in multiple inheritance.
#include<iostream>
using namespace std;
 
class A
{
protected:
    int x;
public:
    A() { x = 10; }
};
 
class B
{
protected:
    int x;
public:
    B() { x = 20; }
};
 
class C: public A, public B
{
public:
void fun()
{
    cout << "A's x is " << A::x;
    cout << "\nB's x is " << B::x;
}
};
 
int main()
{
    C c;
    c.fun();
    return 0;
}
#include <bits/stdc++.h>
#include <iostream>
using namespace std;
#define nline "\n"
 
// Global Declarations
 
string name1 = "GFG";
string favlang = "python";
string companyName = "GFG_2.0";
 
// You can also do the same thing in classes as we did in
// our struct example
 
class Developer {
public:
    string name = "krishna";
    string favLang = "c++";
    string company = "GFG";
 
    // Accessing Global Declarations
 
    Developer(string favlang, string company)
        : favLang(favlang)
        , company(companyName)
    {
    }
};
 
int main()
{
    Developer obj = Developer("python", "GFG");
    cout << "favourite Language : " << obj.favLang << endl;
    cout << "company Name : " << obj.company << nline;
}
// Use of scope resolution class inside another class.
#include <iostream>
using namespace std;
 
class outside {
public:
    int x;
    class inside {
    public:
        int x;
        static int y;
        int foo();
    };
};
int outside::inside::y = 5;
 
int main()
{
    outside A;
    outside::inside B;
}
