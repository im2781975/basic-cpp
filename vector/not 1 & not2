
// C++ program to demonstrate 
// not1 function template 

  
#include <bits/stdc++.h> 

using namespace std; 

  

struct pred { 

    bool operator()(const int i) const

    { 

        return (i % 2 == 0); 

    } 

  

    // defines argument_type for unary functor 

    // it is begin used by not1 

    // as argument_type 

    typedef int argument_type; 
}; 

  
// Driver code 

int main() 
{ 

    vector<int> odd{ 1, 2, 3, 4, 5, 

                     6, 7, 8, 9, 10 }; 

  

    // simple pred functor use 

    // it removes even numbers 

    auto end 

        = remove_if(odd.begin(), 

                    odd.end(), 

                    pred()); 

  

    odd.resize(distance(odd.begin(), end)); 

  

    cout << "removal of even elements: "; 

    for (int i = 0; i < odd.size(); i++) { 

        cout << odd[i] << " "; 

    } 

    cout << "\n"; 

  

    vector<int> even{ 1, 2, 3, 4, 5, 

                      6, 7, 8, 9, 10 }; 

  

    // complement of pred using not1 

    // which removes odd numbers 

    end 

        = remove_if(even.begin(), 

                    even.end(), 

                    not1(pred())); 

  

    even.resize(distance(even.begin(), end)); 

  

    cout << "removal of odd elements: "; 

    for (int i = 0; i < even.size(); i++) { 

        cout << even[i] << " "; 

    } 

  

    return 0; 
} 
 
Output:
removal of even elements: 1 3 5 7 9 
removal of odd elements: 2 4 6 8 10
not2: This function takes binary functor as argument and returns complement functor of it.
Syntax:

template <class Predicate> 
  binary_negate<Predicate> 
    not2 (const Predicate& pred)
{
  return binary_negate<Predicate>(pred);
}
Parameters: The function accepts one mandatory parameter pred which specifies the binary function object to be negated.

Return Value: The function returns the negated binary object.

Example:

// C++ program to demonstrate 
// not2 function template 

  
#include <bits/stdc++.h> 

using namespace std; 

  

int main() 
{ 

    vector<int> vec{ 4, 2, 7, 9, 3, 5, 10, 6 }; 

  

    // simple use of not2 just provide binary 

    // functor and it will return it complement 

    sort(vec.begin(), vec.end(), not2(less<int>())); 

  

    for (int i = 0; i < vec.size(); i++) { 

        cout << vec[i] << " "; 

    } 

    return 0; 
} 
 
Output:
10 9 7 6 5 4 3 2
